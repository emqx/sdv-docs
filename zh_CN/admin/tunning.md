# 性能调优指南

本章节提供一些常见的性能调优方案和自限性资源隔离方法。用户可根据提示自行针对特殊应用场景进行对应的配置修改。

## 消息总线模块调优
消息总线是 sdv-flow 中用于提供数据的可互操作性的基础服务，其包括了 MQTT 消息服务和消息队列功能。

### MQTT 消息服务调优

sdv-flow 均为多线程程序，其中的 MQTT 消息服务也不例外。其内建 Actor 编程模型并行化计算负载，内置全异步 I/O 框架，能够最大化利用多核能力。在此基础上我们针对 Linux 平台和 MQTT 协议优化后，成功将负载平均分配到每个 CPU 核。因此 NanoMQ 在现代 SMP 系统能够以更少的 CPU 资源占用去承担高达一百万每秒的消息吞吐压力。

而强大的消息吞吐能力，可能会受到消费端能力影响而导致消息积压，内存增长。为此可以通过限制内部物理线程和逻辑线程数量来控制。

```
system {
  // 物理线程数量，可以根据运行平台的 CPU 核心数和超线程能力配置。
  // 例如运行于 aarch64 Cortex A53 8 core 上时，应设置成 8 来获得最大的吞吐能力。也可以设置成 4 来限制其在最大负载压力下的 CPU 占用。（设置成 4 即最大占用400%， 设置成 8 就是最大占用400%，即全核占用）
	num_taskq_thread = 0
	max_taskq_thread = 0
  // 逻辑线程数量，显著影响内存占用。决定了同一时间能够并行并发处理的最大逻辑操作数量。
  // 每个消息触发的动作：包括接收订阅，内部钩子函数，桥接的消息上行，本地消息落盘存储，发布投递等具有明确前后上下文顺序需要保存的操作即视为需要占用一个逻辑线程。
  // 一般建议设置成物理线程的 2-4 倍。若内存不足，也可以配置更小，但随之带来丢失消息和会话积压的风险。 
	parallel = 0
}
```

### MQTT 协议调优。
此部分介绍标准 MQTT 消息服务的调优项。
```
mqtt {
	# # 最大接受的MQTT消息大小，范围从 1 Byte-260 MB。一般直接设置成最大的 256 MB
	max_packet_size = 1KB
	
	# # 每个客户端各自独立享有的飞行窗口长度，当收发速率不匹配的时候，客户端未能及时接收的消息将会缓存在此飞行窗口中。
	# # 此配置显著影响服务的最大内存消耗，若硬件内存有限，可以尝试缩小此项参数
	max_mqueue_len = 2048

	
	# # 控制全局重试定时器间隔，控制总线服务检查会话过期，消息重发间隔的频率。此参数会在有大量客户端连接时显著影响 CPU 使用。
	# # sdv-flow 由于本地总线连接客户端较少，故此项可以设置为2-5s 为宜。
	retry_interval = 10s
	
	# # MQTT 客户端的心跳退避参数。由于 sdv-flow 所对接的本地跨域服务都运行在车载以太网上，延时较低。故建议此项沿用默认值 1.25。
	keepalive_multiplier = 1.25
	
}
```

### MQTT 桥接调优
桥接是完成车云数据同步的重要通道，所以对于其的调优配置也至关重要。
以下列出需要重点关注的一些调优配置选项。

```
bridges.mqtt.emqx1 {

	# # 若使用 MQTT v5 进行桥接，在享受新版本协议的新功能的同时，也需要注意一些 V5 的特殊配置，如 QoS 限额，单消息最大长度可能对业务造成的影响。
	proto_ver = 5
	
	# # 此为客户端的最大心跳间隔时间，此选项影响基于 TCP 连接的 MQTT 会话的网络耐受程度。
	# # 当此选项配置的数字较高，如120s，可以减少会话断开的几率
	# # 但在一些网络不稳定的场景此选项设置过高，会造成断网检测过慢二带来的“假链接”情况，导致数据丢失。
	keepalive = 60s

	# # 桥接客户端的重连退避时间。当大批量的车辆同一时间进行重连时很容易造成类 DDoS 攻击。
	# # 例如，通过配置此选项为 60s，让桥接客户端自动在 0-60s 内自动按照指数函数获取重连间隔时间，尽可能让每辆车的重连分散到不同的时间点。
	backoff_max = 60s
	
	# #  影响离线消息下发，详情请参阅 MQTT 协议教程。
	clean_start = false

	# #  MQTT V5 连接属性，只有使用 MQTT V5 桥接时才需要此部分配置
	conn_properties = {
		# # 若使用 MQTTV5 则需要特别注意其内置的最大包大小限制，超过此数值的包都将被丢弃并造成连接断开
		# # Value: 1 ~ 4294967295
		maximum_packet_size = 1024
		
		# # 当使用客户端的会话保持功能时，此数值是客户端请求的最大保持会话时间，超过后会话将被清理，断网缓存消息将被释放。
		session_expiry_interval = 0

	}
	......
	
	
	# # 桥接的逻辑线程数量，此为专门为桥接配置的监听 Context，只影响从远端接受消息的能力。
	max_parallel_processes = 2
	
	# # 桥接客户端的内部发送消息的飞行窗口队列，影响内存占用
	max_send_queue_len = 32
	
	# # 桥接客户端的内部接受消息的飞行窗口队列，影响内存占用
	max_recv_queue_len = 128
}

```

### 消息队列配置调优

MQTT-Stream 消息对列是数据总线模块的重要功能，能够支持对流入的数据进行持久化存储并提供滚动查询能力。
<img width="621" alt="image" src="https://github.com/user-attachments/assets/c082ac7e-5161-45b2-a10f-c27c58d39690">

用户可以配置MQTT主题和消息队列的映射关系，以及配置流类型。所有流入到该主题的消息就会被持久化到对应的分区文件中。分区文件的存储格式采用业界开源标准：Parquet（https://parquet.apache.org/）。
此部分的配置分为两个部分，交换机（exchanger）和分区文件（Parquet）。

交换机负责控制消息主题和消息队列的映射关系。可以通过配置不同命名的交换机来分配消息到不同的队列中。
例如`exchange_client.mq1` 和 `exchange_client.mq1` 可以分别对应不同的主题来完成消息的持久化。
```
# #====================================================================
# # 消息队列交换机配置
# #====================================================================
exchange_client.mq1 {
	// 消息队列消费/查询服务的监听端口
	exchange_url = "tcp://127.0.0.1:10000"
	exchange {
		# # 命中此主题的消息将进入消息队列
		topic = "exchange/sdv/#",
		# # MQ name
		name = "exchange_no1",
		# # 消息队列内置的环形内存队列
		ringbus = {
			name = "ringbus",
			# # 但塞满了这里配置的环形队列最大长度后，将触发配置的定义目标动作。
			cap = 1000,
			# # 对于 sdv-flow， 请使用 2 - 消息将统一由内部异步I/O 返回。会有内置的分区文件系统根据 Parquet 配置进行刷盘。
			fullOp = 2
		}
	}
}
```
分区文件配置和交换机配置一起决定了消息队列最大可以缓存的消息条数和时间长度。这对于针对硬件资源合理设计整车数据可回溯搜索的时间长度至关重要。
例如整车信号12706个，前置的跨域通信代理每 100ms 聚合采样一次产生一条消息，然后以 10 msg/s 的速率将整车数据推入消息队列，ringbus 长度为 800，则一共存储 800 * 10 = 8k 条消息后进行压缩和刷盘。
8k 条消息记录的时间长度为100ms * 10 * 800 = 80s。经计算这 80k 条消息所含原始数据总量为 13 Mb，压缩后为 1.5 Mb，则可以估算每 80s 产生的落盘数据为 1.5Mb。
若域控制器有 1G Emmc可存储空间，则可存储整车数据时长 15h左右 （具体时长根据车辆行驶状态和数据大小以及压缩率有关。）

```
# #====================================================================
# # 分区文件配置 Parquet configuration
# #====================================================================
parquet {
	# # 刷盘前可选使用压缩算法或不压缩，有 uncompressed | snappy | gzip | brotli | zstd | lz4 可选
	compress = uncompressed
	# # 刷盘前是否进行加密，供对于数据安全有更高要求的用户使用。请注意加密动作发生在压缩之后。
	encryption {
		# # Set a key retrieval metadata.
		# #
		# # Value: String
		key_id = kf
		# # Parquet encryption key.
		# #
		# # Value: String key must be either 16, 24 or 32 bytes.
		key = "0123456789012345"
		# # 只支持使用以下 2 种加密方式
		# # Value: AES_GCM_CTR_V1 | AES_GCM_V1
		type = AES_GCM_V1
	}
	# # 分区文件保存的位置
	dir = "/tmp/nanomq-parquet"
	# # 分区文件的统一命名前缀
	file_name_prefix = ""
	# # 最大可持久化的分区文件数量
	file_count = 5
	# # 最大的单一 Parquet 分区文件大小
    	file_size = 1KB
	# # 由于查询回溯（又名数据回放）操作对 CPU 和 内存的消耗都较为巨大，为避免突然数据回放请求导致负载过高二引起操作系统不必要的保护动作，可以通过此参数限制同一时刻允许的最大查询请求数量。
    	limit_frequency = 5
}
```

## 流处理模块配置调优
